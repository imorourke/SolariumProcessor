#ifndef K_TSK
#define K_TSK

#include kcpu.cb
#include kirq.cb
#include kserialio.cb
#include std_list.cb

struct k_tsk_thread_frame_t {
    last_ptr: u32;
    stack: *u8;
    owns_stack: u8;
}

global K_TSK_ORIG: u32 = 0;
global K_TSK_CURR: *std_list_node_t = 0;
global K_TSK_ROOT: *std_list_node_t = 0;

asmfn k_tsk_main() void {
    // Load stack location from root
    "%LDLOC% 8:u32";
    ".loadloc %{K_TSK_ROOT}%";
    "ld 8:u32 8"; // Load the node root
    "tz 8";
    "ret"; // Return if there is no root node
    "ld 8:u32 8"; // Load the data pointer
    "tz 8";
    "ret"; // Return if there is no stack value
    "ld 8:u32 8"; // Load the last stack location
    "%LDLOC% 10:u32";
    ".loadloc %{K_TSK_ORIG}%";
    "sav 10:u32 $sp";
    "copy $sp 8";
    "ret";
}

fnint k_tsk_yield() void {
    asm { "intoff"; }
    asm {
        "%LDLOC% 14:u32";
        ".loadloc %{K_TSK_CURR}%";
        "ld 14:u32 14";
        "ld 14:u32 14";
        "sav 14:u32 $sp";
    }
    K_TSK_CURR = K_TSK_CURR->next;
    if (K_TSK_CURR == 0) {
        K_TSK_CURR = K_TSK_ROOT;
    }
    asm {
        "%LDLOC% 14:u32";
        ".loadloc %{K_TSK_CURR}%";
        "ld 14:u32 14";
        "ld 14:u32 14";
        "ld 14:u32 14";
        "copy $sp 14";
        "retint";
    }
}

fn k_tsk_cleanup(remove_val: std_list_node_t) void {
    asm { "intoff"; }
    def frame: *k_tsk_thread_frame_t = remove_val.data;
    if (frame->owns_stack) {
        k_free(frame->stack);
    }
    k_free(remove_val.data);
    K_TSK_CURR = remove_val.next;
    K_TSK_ROOT = std_list_remove(K_TSK_ROOT, &remove_val);
    if (K_TSK_CURR == 0) {
        K_TSK_CURR = K_TSK_ROOT;
    }

    if (K_TSK_CURR == 0) asm {
        "%LDLOC% 15:u32";
        ".loadloc %{K_TSK_ORIG}%";
        "ld 16:u16 15";
        "ldi 14:u16 0";
        "sav 15:u32 14";
        "copy $sp 16";
        "ret";
    }

    // Load the new task pointer and continue execution (copied from the end of k_tsk_yield)
    // This needs to return from asm because we allocate stack space above for the temporary frame pointer.
    // So, technically we are wasting some bytes off the end to cleanup our stack space. But, because we
    // are switching tasks, we are okay with loosing this space. But those instructions will never be hit.
    asm {
        "%LDLOC% 14:u32";
        ".loadloc %{K_TSK_CURR}%";
        "ld 14:u32 14";
        "ld 14:u32 14";
        "ld 14:u32 14";
        "copy $sp 14";
        "ret";
    }
}

fn k_tsk_init(func: fn() void, stack: *u8) void {
    def current: *k_tsk_thread_frame_t;
    current = k_malloc(sizeof(k_tsk_thread_frame_t));
    def new_node: *std_list_node_t = std_list_create_node(current);

    current->stack = stack;
    def return_stack: *k_cpu_stack_frame_t = current->stack;
    def start_stack: *k_cpu_stack_frame_t = return_stack + 1;

    // Create the cleanup stack frame
    return_stack->program_counter = k_tsk_cleanup;
    return_stack->argument_base = new_node;
    return_stack->stack_pointer = return_stack;

    // Create the main stack frame for the requested function
    start_stack->program_counter = func;
    start_stack->status_flags = 1; // Enable Interrupts on the new stack
    start_stack->stack_pointer = start_stack;

    // Set the last pointer off the end of the second stack frame
    current->last_ptr = (return_stack + 2) : u32;

    if (K_TSK_ROOT == 0) {
        K_TSK_ROOT = new_node;
        K_TSK_CURR = K_TSK_ROOT;
    } else {
        K_TSK_ROOT = std_list_append(K_TSK_ROOT, new_node);
    }
}

#endif // K_TSK
