#ifndef K_TSK
#define K_TSK

#include kcpu.cb
#include kserialio.cb

const K_TSK_STACK_NUM: u32 = 4;
global K_TSK_THREAD_NUM: u32 = 0;
global K_TSK_THREAD_CURR: u32 = 0;

struct k_tsk_thread_stack_t {
    last_ptr: u32;
    stack: *u8;
}

global K_TSK_THREAD_STACK: [K_TSK_STACK_NUM]k_tsk_thread_stack_t;

asmfn k_tsk_main() void {
    "%LDLOC% 8:u32";
    ".loadloc %{K_TSK_THREAD_NUM}%";
    "ld 8:u32 8";
    "tz 8";
    "ret";
    "%LDLOC% 9:u32";
    ".loadloc %{K_TSK_THREAD_STACK}%";
    "ld 9:u32 9";
    "copy $sp 9";
    "ret";
}

asmfn k_tsk_yield() void {
    "intoff";
    "; Increment K_TSK_THREAD_NUM to next thread";
    "%LDLOC% 8:u32";
    ".loadloc %{K_TSK_THREAD_NUM}%";
    "ld 8:u32 8";
    "%LDLOC% 9:u32";
    ".loadloc %{K_TSK_THREAD_CURR}%";
    "ld 10:u32 9";
    "copy 16 10";
    "ldi 11:u16 1";
    "add 10:u32 10 11";
    "rem 10:u32 10 8";
    "sav 9:u32 10";
    "; Swap stack pointer";
    "; 10 = new pointer";
    "; 16 = old pointer";
    "ldi 8:u16 #{k_tsk_thread_stack_t}#";
    "mul 10:u32 10 8";
    "mul 16:u32 16 8";
    "%LDLOC% 9:u32";
    ".loadloc %{K_TSK_THREAD_STACK}%";
    "add 10:u32 10 9";
    "add 16:u32 16 9";
    "sav 16:u32 $sp";
    "ld $sp:u32 10";
    "inton";
    "retint";
}

asmfn k_tsk_cleanup() void {
    "reset";
    "ret";
}

fn k_tsk_init(func: fn() void, stack: *u8) void {
    if (K_TSK_THREAD_NUM < K_TSK_STACK_NUM) {
        def current: *k_tsk_thread_stack_t = &K_TSK_THREAD_STACK[K_TSK_THREAD_NUM];
        current->stack = stack;
        def return_stack: *u32 = current->stack;
        def start_stack: *u32 = return_stack + K_CPU_NUM_REGISTERS;
        return_stack[0] = k_tsk_cleanup;
        return_stack[2] = start_stack;
        k_io_print_stat("Base Struct", current);
        k_io_print_stat("Base Stack", start_stack);
        start_stack[0] = func;
        start_stack[1] = 1; // Enable Interrupts on the new stack
        k_io_print_stat("Function Location", func : u32);
        start_stack[2] = (start_stack + 32) : u32;
        current->last_ptr = start_stack[2];
        k_io_print_stat("Stack Location", current->last_ptr);
        k_io_print_stat("Stack Size", (current->last_ptr : u32) - (start_stack : u32));
        K_TSK_THREAD_NUM = K_TSK_THREAD_NUM + 1;
        k_io_print_stat("Current Thread Count", K_TSK_THREAD_NUM);
        k_io_print("\n");
    } else {
        k_io_print("Exceed allowed thread count\n");
    }
}

#endif // K_TSK
