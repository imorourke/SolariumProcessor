#ifndef K_TSK
#define K_TSK

#include kcpu.cb
#include kirq.cb
#include kserialio.cb
#include std_list.cb

struct k_tsk_thread_frame_t {
    last_ptr: u32;
    stack: *u8;
    owns_stack: u8;
}

global K_TSK_ORIG: u32 = 0;
global K_TSK_CURR: *std_list_node_t = 0;
global K_TSK_ROOT: *std_list_node_t = 0;

asmfn k_tsk_main() void {
    // Load stack location from root
    "%LDLOC% 8:u32";
    ".loadloc %{K_TSK_ROOT}%";
    "ld 8:u32 8"; // Load the node root
    "ld 8:u32 8"; // Load the data pointer
    "tz 8";
    "ret"; // Return if there is no root node
    "ld 8:u32 8"; // Load the last stack location
    "%LDLOC% 10:u32";
    ".loadloc %{K_TSK_ORIG}%";
    "sav 10:u32 $sp";
    "copy $sp 8";
    "ret";
}

fn k_tsk_cleanup(remove_val: std_list_node_t) void {
    asm { "intoff"; }
    def frame: *k_tsk_thread_frame_t = remove_val.data;
    if (frame->owns_stack) {
        k_free(frame->stack);
    }
    k_free(remove_val.data);
    K_TSK_CURR = remove_val.next;
    K_TSK_ROOT = std_list_remove(K_TSK_ROOT, &remove_val);
    if (K_TSK_CURR == 0) {
        K_TSK_CURR = K_TSK_ROOT;
    }
    // TODO - yield without incrementing value - otherwise we will skip the actual next thread and skip a cycle
}

fn k_tsk_init(func: fn() void, stack: *u8) void {
    def current: *k_tsk_thread_frame_t;
    current = k_malloc(sizeof(k_tsk_thread_frame_t));
    def new_node: *std_list_node_t = std_list_create_node(current);

    current->stack = stack;
    def return_stack: *u32 = current->stack;
    def start_stack: *u32 = return_stack + K_CPU_NUM_REGISTERS;
    return_stack[K_CPU_REG_PROGRAM_COUNTER] = k_tsk_cleanup;
    return_stack[K_CPU_REG_STACK_POINTER] = start_stack;
    start_stack[K_CPU_REG_PROGRAM_COUNTER] = func;
    start_stack[K_CPU_REG_STATUS] = 1; // Enable Interrupts on the new stack
    start_stack[K_CPU_REG_STACK_POINTER] = (start_stack + 32) : u32;
    current->last_ptr = start_stack[2];

    if (K_TSK_ROOT == 0) {
        K_TSK_ROOT = new_node;
        K_TSK_CURR = K_TSK_ROOT;
    } else {
        K_TSK_ROOT = std_list_append(K_TSK_ROOT, new_node);
    }

    k_io_print_stat("Current Thread Count", std_list_len(K_TSK_ROOT));
    k_io_print("\n");
}

fnint k_tsk_yield() void {
    asm { "intoff"; }
    if (K_TSK_ROOT == 0) asm {
        "%LDLOC% 15:u32";
        ".loadloc %{K_TSK_ORIG}%";
        "ld 16:u16 15";
        "ldi 14:u16 0";
        "sav 15:u32 14";
        "copy $sp 16";
        "retint";
    }
    asm {
        "%LDLOC% 14:u32";
        ".loadloc %{K_TSK_CURR}%";
        "ld 14:u32 14";
        "ld 14:u32 14";
        "sav 14:u32 $sp";
    }
    K_TSK_CURR = K_TSK_CURR->next;
    if (K_TSK_CURR == 0) {
        K_TSK_CURR = K_TSK_ROOT;
    }
    asm {
        "%LDLOC% 14:u32";
        ".loadloc %{K_TSK_CURR}%";
        "ld 14:u32 14";
        "ld 14:u32 14";
        "ld 14:u32 14";
        "copy $sp 14";
    }
}

#endif // K_TSK
