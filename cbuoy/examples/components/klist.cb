#ifndef STD_LIST
#define STD_LIST

#include kmalloc.cb

struct std_list_node {
    data: *u8;
    owns_data: u8;
    next: *std_list_node;
}

fn std_list_create_node(data: *u8, owns_data: u8) *std_list_node {
    def node: *std_list_node = k_malloc(sizeof(std_list_node));
    node->data = data;
    node->owns_data = owns_data;
    node->next = 0;
    return node;
}

fn std_list_destroy(root: *std_list_node) void {
    def next: *std_list_node = root;
    def tmp: *std_list_node;
    while (next != 0) {
        tmp = next;
        next = next->next;
        if (tmp->owns_data) {
            k_free(tmp->data);
        }
        k_free(tmp);
    }
}

fn std_list_remove(root: *std_list_node, remove: *std_list_node) *std_list_node {
    def n: *std_list_node = root;
    if (remove == root) {
        n = n->next;
        root->next = 0;
        std_list_destroy(root);
        return n;
    } else {
        while (n->next != 0) {
            if (n->next : *std_list_node == remove) { // TODO - Fix this
                n->next = n->next->next;
                remove->next = 0;
                std_list_destroy(remove);
            }
        }
        return root;
    }
}

fn std_list_append(root: *std_list_node, new: *std_list_node) *std_list_node {
    if (root == 0) {
        return 0;
    }

    def n: *std_list_node = root;
    while (n->next != 0) {
        n = n->next;
    }

    n->next = new;
    return root;
}

fn std_list_find(root: *std_list_node, func: fn(*u8) u8) *std_list_node {
    while (root != 0) {
        if (func(root->data)) {
            return root;
        }
        root = root->next;
    }
    return 0;
}

fn std_list_foreach(root: *std_list_node, func: fn(*u8, *u8) void, state: *u8) void {
    while (root != 0) {
        func(root->data, state);
        root = root->next;
    }
}

#endif // STD_LIST
