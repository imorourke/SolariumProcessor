const STACK_SIZE: u32 = 1024;
const STACK_NUM: u32 = 4;
global THREAD_NUM: u32 = 0;
global THREAD_CURR: u32 = 0;

struct thread_stack_t {
    last_ptr: u32;
    stack: [STACK_SIZE]u8;
}

global THREAD_STACK: [STACK_NUM]thread_stack_t;

global SERIAL_OUT_LOC: *u8 = 0xA000u32 + 5;

asmfn scheduler() void {
    "intoff";
    "inton";
    "retint";
}

asmfn tsk_yield() void {
    "intoff";
    "inton";
    "ret";
}

asmfn print(c: *u8) void {
    "ldn 8:u32";
    ".loadloc %{SERIAL_OUT_LOC}%";
    "ld 8:u32 8";
    ".align";
    "ldi 9:u16 1";
    "ld 10:u32 $arg";
    "ldi 11:u16 @{c}@";
    "add 10:u32 10 11";
    "ld 11:u8 10";
    "tz 11";
    "jmpri 16";
    "sav 8:u8 11";
    "add 10:u32 10 9";
    "jmpri -20";
    "ret";
}

fn print_digit(v: u8) void {
    if (v < 10) {
        *SERIAL_OUT_LOC = '0' + v;
    } else {
        *SERIAL_OUT_LOC = '?';
    }
}

fn print_uint(v: u32) void {
    def chars: [12]u8;
    def cp: *u8 = &chars;
    if (v == 0) {
        print_digit(0);
    } else {
        while (v != 0) {
            *cp = v % 10;
            v = v / 10;
            cp = cp + 1;
        }
        while (cp != &chars) {
            cp = cp - 1;
            print_digit(*cp);
        }
    }
}

fn init_thread(func: fn() void) void {
    if (THREAD_NUM < STACK_NUM) {
        def current: *thread_stack_t = &THREAD_STACK[THREAD_NUM];
        def current_stack: *u8 = THREAD_STACK[THREAD_NUM].stack;
        current_stack[0] = func;
        current_stack[2] = ((current_stack : *u32) + 32) : *u8;
        (*current).last_ptr = current_stack[2];
        print("Stack Location: ");
        print_uint((*current).last_ptr);
        print("\n");
        print("Stack Size: ");
        print_uint(((*current).last_ptr : u32) - (current_stack : u32));
        print("\n");
        THREAD_NUM = THREAD_NUM + 1;
        print("Current Thread Count: ");
        print_uint(THREAD_NUM);
        print("\n");
    } else {
        print("Exceed allowed thread count\n");
    }
}

fn main_tsk_a() void {
    while (1) {
        print("TSK_A\n");
    }
}

fn main_tsk_b() void {
    while (1) {
        print("TSK_B\n");
    }
}

asmfn tsk_main() void {
    "ldn 8:u32";
    ".loadloc %{THREAD_NUM}%";
    "ld 8:u32 8";
    "tz 8";
    "ret";
    "ldn 9:u32";
    ".loadloc %{THREAD_STACK}%";
    "ld 9:u32 9";
    "copy $sp 9";
    "ret";
}

fn main() void {
    def irq0_loc: *u32 = 0x100;
    *irq0_loc = scheduler;
    init_thread(main_tsk_a);
    init_thread(main_tsk_b);
    tsk_main();
}
