#ifndef KFS
#define KFS

#include kdbg.cb
#include kmalloc.cb
#include krtc.cb
#include kserialio.cb

const K_FS_ENTRY_END: u16 = 0xFFFF;

const K_FS_VOL_NAME_LEN: u32 = 16;
const K_FS_ENTRY_NAME_LEN: u32 = 12;

const K_FS_ENTRY_TYPE_DIR: u8 = 1;
const K_FS_ENTRY_TYPE_FILE: u8 = 2;

struct k_fs_vol_header_t {
    version: u16;
    sector_size: u16;
    sector_count: u16;
    volume_name: [K_FS_VOL_NAME_LEN]u8;
    root_sector: u16;
    //padding[40]u8
}

struct k_fs_directory_entry_t {
    base_block: u16,
    attributes: u8,
    entry_type: u8,
    name: [K_FS_ENTRY_NAME_LEN]u8;
}

struct k_fs_entry_header_t {
    entry_type: u8;
    reserved: u8;
    parent: u16;
    modification_time: k_datetime_t;
    payload_size: u32;
}

struct k_fs_disk_control_t {
    device_id: u16;
    parked: u8;
    ready: u8;
    target_offset: u32;
    move_to_offset: u8;
    write_segment: u8;
    memory_size: u16;
    data: [256]u8;
}

struct k_fs_disk_t {
    disk_num: u32;
    vol_hdr: k_fs_vol_header_t;
    entry_table: *u16;
    ctl: *k_fs_disk_control_t;
}

const DISK_LOC: *u8 = 0xB000;

fn k_fs_disk_move(ctl: *k_fs_disk_control_t, offset: u32) void {
    // Set the control block
    ctl->target_offset = offset;
    ctl->move_to_offset = 1;

    // Wait for the ctl to be ready
    while (ctl->ready == 0) {
        if (K_DBG_ENABLED) {
            k_io_print("Waiting...\n");
        }
    }
}

fn k_fs_entry_valid(entry: u16) -> u8 {
    return entry != 0 && entry != K_FS_ENTRY_END;
}

fn k_fs_disk_open(device_num: u32) *k_fs_disk_t {
    // Allocate the disk
    def dev: *k_fs_disk_t = k_malloc(sizeof(k_fs_disk_t));
    k_memset(dev, 0, sizeof(k_fs_disk_t));
    dev->disk_num = device_num;

    // Setup the disk control block
    dev->ctl = DISK_LOC;
    dev->ctl->parked = 0;
    dev->ctl->memory_size = 0;

    // Copy the volume header
    k_fs_disk_move(dev->ctl, 0);
    if (K_DBG_ENABLED) {
        k_io_print("Copying Header ");
        k_io_print_uint(&(dev->vol_hdr));
        k_io_print(" from ");
        k_io_print_uint(&dev->ctl->data);
        k_io_print(" with size ");
        k_io_print_uint(sizeof(k_fs_vol_header_t));
        k_io_print("\n");
    }
    k_memcpy(&(dev->vol_hdr), &dev->ctl->data, sizeof(k_fs_vol_header_t));

    // Setup the entry table
    def total_size: u32 = sizeof(u16) * (dev->vol_hdr).sector_count;
    dev->entry_table = k_malloc(total_size);

    def current_size: u32 = 0;
    def table: *u8 = dev->entry_table;
    def mem_size: u32 = dev->ctl->memory_size;

    if (K_DBG_ENABLED) {
        k_io_print("Reading entry table\n");
    }

    while (current_size < total_size) {
        def size_to_read: u32 = total_size - current_size;
        if (size_to_read > mem_size) {
            size_to_read = mem_size;
        }

        if (K_DBG_ENABLED) {
            k_io_print_uint(current_size);
            k_io_print("\n");
        }
        k_fs_disk_move(dev->ctl, dev->vol_hdr.sector_size + current_size);
        k_memcpy(table + current_size, &dev->ctl->data, size_to_read);
        current_size = current_size + size_to_read;
    }

    return dev;
}

fn k_fs_read_header(dev: *k_fs_disk_t, entry: u16, header: *k_fs_entry_header_t) i32 {
    if (dev->entry_table[entry] == 0) {
        return -1;
    }
    k_fs_disk_move(dev->ctl, dev->vol_hdr.sector_size * entry);
    dev->ctl->memory_size = 0;
    k_memcpy(header, &dev->ctl->data, sizeof(k_fs_entry_header_t));
    return 0;
}

fn k_fs_read_entry_data(dev: *k_fs_disk_t, header: *k_fs_entry_header_t, entry: u16, data: *u8, size: u32, offset: u32) -> i32 {
    return -1;
}

fn k_fs_read_directory_entries(dev: *k_fs_disk_t, entry: u16, entries: *k_fs_directory_entry_t, entry_size: u32, entry_offset: u32) i32 {
    if (entries == 0) {
        return -1;
    } else if (dev->entry_table[entry] == 0) {
        return -1;
    } else if (entry_size == 0) {
        return 0;
    }

    def header: k_fs_entry_header_t;
    if (k_fs_read_header(dev, entry, &header) != 0) {
        return -1;
    } else if (header.entry_type != K_FS_ENTRY_TYPE_DIR) {
        return -1;
    }

    def current_offset: u32 = sizeof(k_fs_entry_header_t) + entry_offset * sizeof(k_fs_directory_entry_t);
    def local_offset: u32 = current_offset;
    def sector_size = dev->vol_hdr->sector_size;

    while (local_offset >= sector_size) {
        entry = dev->entry_table[entry];
        local_offset -= sector_size;
        if (!k_fs_entry_valid(entry)) {
            return -1;
        }
    }

    def current_value: u32 = 0;
    def overall_size = header.payload_size + sizeof(k_fs_entry_header_t);

    while (current_value < *entry_size && current_offset < overall_size) {
        entries[current_value] =
    }
}

fn k_fs_disk_close(dev: *k_fs_disk_t) void {
    k_free(dev->entry_table);
    k_free(dev);
}

#endif // KFS
