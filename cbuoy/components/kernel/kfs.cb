#ifndef KFS
#define KFS

#include kconfig.cb
#include kdbg.cb
#include kmalloc.cb
#include krtc.cb
#include kserialio.cb

#include <std/string.cb>

const K_FS_ENTRY_END: u16 = 0xFFFF;

const K_FS_VOL_NAME_LEN: u32 = 16;
const K_FS_ENTRY_NAME_LEN: u32 = 12;

const K_FS_ENTRY_TYPE_DIR: u8 = 1;
const K_FS_ENTRY_TYPE_FILE: u8 = 2;

struct k_fs_vol_header_t {
    version: u16;
    sector_size: u16;
    sector_count: u16;
    volume_name: [K_FS_VOL_NAME_LEN]u8;
    root_sector: u16;
}

struct k_fs_directory_entry_t {
    base_block: u16;
    attributes: u8;
    entry_type: u8;
    name: [K_FS_ENTRY_NAME_LEN]u8;
}

struct k_fs_entry_header_t {
    entry_type: u8;
    reserved: u8;
    parent: u16;
    modification_time: k_datetime_t;
    payload_size: u32;
}

struct k_fs_disk_control_t {
    device_id: u16;
    parked: u8;
    ready: u8;
    target_offset: u32;
    move_to_offset: u8;
    write_segment: u8;
    memory_size: u16;
    data: [256]u8;
}

struct k_fs_disk_t {
    disk_num: u32;
    vol_hdr: k_fs_vol_header_t;
    entry_table: *u16;
    ctl: *k_fs_disk_control_t;
    entry_table_dirty: u8;
}

const DISK_LOC: *u8 = K_LOC_DEVICE_HD_START;

fn k_fs_disk_move(ctl: *k_fs_disk_control_t, offset: u32) void {
    // Set the control block
    ctl->target_offset = offset;
    ctl->move_to_offset = 1;

    // Wait for the ctl to be ready
    while (ctl->ready == 0) {
        if (K_DBG_ENABLED) {
            k_io_print("Waiting...\n");
        }
    }
}

fn k_fs_entry_valid(entry: u16) u8 {
    return entry != 0 && entry != K_FS_ENTRY_END;
}

fn k_fs_next_sector(dev: *k_fs_disk_t, entry: u16) u16 {
    if (!k_fs_entry_valid(entry)) {
        return 0;
    }

    def next: u16 = dev->entry_table[entry];
    if (k_fs_entry_valid(next)) {
        return next;
    } else {
        return 0;
    }
}

fn k_fs_data_write(dev: *k_fs_disk_t, disk_offset: u32, data: *u8, size: u32) i32 {
    def current_size: u32 = 0;
    def mem_size: u32 = dev->ctl->memory_size;

    while (current_size < size) {
        def size_to_write: u32 = size - current_size;
        if (size_to_write > mem_size) {
            size_to_write = mem_size;
        }

        if (K_DBG_ENABLED) {
            k_io_print_uint(current_size);
            k_io_print("\n");
        }

        dev->ctl->memory_size = size_to_write;
        k_fs_disk_move(dev->ctl, disk_offset + current_size);
        k_memcpy(&dev->ctl->data, data + current_size, size_to_write);
        dev->ctl->write_segment = 1;
        current_size = current_size + size_to_write;
    }

    dev->ctl->memory_size = 0;
    return 0;
}

fn k_fs_data_read(dev: *k_fs_disk_t, disk_offset: u32, data: *u8, size: u32) i32 {
    def current_size: u32 = 0;
    dev->ctl->memory_size = 0;
    def mem_size: u32 = dev->ctl->memory_size;

    while (current_size < size) {
        def size_to_read: u32 = size - current_size;
        if (size_to_read > mem_size) {
            size_to_read = mem_size;
        }

        if (K_DBG_ENABLED) {
            k_io_print_uint(current_size);
            k_io_print("\n");
        }

        k_fs_disk_move(dev->ctl, disk_offset + current_size);
        k_memcpy(data + current_size, &dev->ctl->data, size_to_read);
        current_size = current_size + size_to_read;
    }

    return 0;
}

fn k_fs_disk_open(device_num: u32) *k_fs_disk_t {
    // Allocate the disk
    def dev: *k_fs_disk_t = k_malloc(sizeof(k_fs_disk_t));
    k_memset(dev, 0, sizeof(k_fs_disk_t));
    dev->disk_num = device_num;

    // Setup the disk control block
    dev->ctl = DISK_LOC;
    dev->ctl->parked = 0;
    dev->ctl->memory_size = 0;

    // Copy the volume header
    k_fs_disk_move(dev->ctl, 0);
    if (K_DBG_ENABLED) {
        k_io_print("Copying Header ");
        k_io_print_uint(&(dev->vol_hdr));
        k_io_print(" from ");
        k_io_print_uint(&dev->ctl->data);
        k_io_print(" with size ");
        k_io_print_uint(sizeof(k_fs_vol_header_t));
        k_io_print("\n");
    }
    k_memcpy(&(dev->vol_hdr), &dev->ctl->data, sizeof(k_fs_vol_header_t));

    // Setup the entry table
    def total_size: u32 = sizeof(u16) * (dev->vol_hdr).sector_count;
    dev->entry_table = k_malloc(total_size);

    def res: i32 = k_fs_data_read(
        dev,
        dev->vol_hdr.sector_size,
        dev->entry_table : *u8,
        sizeof(u16) * (dev->vol_hdr).sector_count,
        );

    if (res != 0) {
        k_io_print("unable to load data table: ");
        k_io_print_int(res);
        k_io_print("\n");
    }

    // Return the device result
    return dev;
}

fn k_fs_write_disk_table(dev: *k_fs_disk_t) i32 {
    def res: i32 = k_fs_data_write(
        dev,
        dev->vol_hdr.sector_size,
        dev->entry_table: *u8,
        sizeof(u16) * dev->vol_hdr.sector_count);

    if (res != 0) {
        return res;
    }

    dev->entry_table_dirty = 0;
    return 0;
}

fn k_fs_read_entry_header(dev: *k_fs_disk_t, entry: u16, header: *k_fs_entry_header_t) i32 {
    if (!k_fs_entry_valid(entry)) {
        return -1;
    }
    k_fs_disk_move(dev->ctl, dev->vol_hdr.sector_size * entry);
    dev->ctl->memory_size = 0;
    k_memcpy(header, &dev->ctl->data, sizeof(k_fs_entry_header_t));
    return 0;
}

fn k_fs_read_entry_data(dev: *k_fs_disk_t, entry: u16, data: *u8, size: *u32, offset: u32) i32 {
    if (!k_fs_entry_valid(entry)) {
        *size = 0;
        k_io_print("\nInvalid Entry: ");
        k_io_print_uint(entry);
        k_io_print("\n");
        return -1;
    }

    dev->ctl->memory_size = 0;

    def entry_hdr: k_fs_entry_header_t;
    if (k_fs_read_entry_header(dev, entry, &entry_hdr) != 0) {
        *size = 0;
        return -1;
    }

    def sector_size: u32 = dev->vol_hdr.sector_size;
    def total_offset: u32 = offset + sizeof(k_fs_entry_header_t);
    while (total_offset >= sector_size) {
        entry = k_fs_next_sector(dev, entry);
        if (entry == 0) {
            *size = 0;
            return -1;
        }
        total_offset = total_offset - sector_size;
    }

    if (offset + *size > entry_hdr.payload_size) {
        *size = entry_hdr.payload_size - offset;
    }

    def data_size: u32 = *size;
    def sector_base: u32 = sector_size * entry;
    def disk_offset: u32 = total_offset;
    def local_offset: u32 = 0;

    while (local_offset < data_size) {
        def copy_size: u32 = data_size;
        def move_sector: u8 = 0;
        if (copy_size > dev->ctl->memory_size) {
            copy_size = dev->ctl->memory_size;
        }

        if (local_offset + copy_size > data_size) {
            copy_size = data_size - local_offset;
        }

        if (disk_offset + copy_size > sector_size) {
            copy_size = sector_size - disk_offset;
            move_sector = 1;
        }

        k_fs_disk_move(dev->ctl, sector_base + disk_offset);

        k_memcpy(data + local_offset, &dev->ctl->data, copy_size);
        local_offset = local_offset + copy_size;
        disk_offset = disk_offset + copy_size;

        if (move_sector) {
            disk_offset = disk_offset - sector_size;
            entry = k_fs_next_sector(dev, entry);
            if (entry == 0) {
                return -1;
            }
            sector_base = sector_size * entry;
        }
    }

    return 0;
}

fn k_fs_read_directory_entries(dev: *k_fs_disk_t, entry: u16, entries: *k_fs_directory_entry_t, entry_size: *u32, entry_offset: u32) i32 {
    if (entries == 0) {
        return -1;
    } else if (dev->entry_table[entry] == 0) {
        return -1;
    } else if (entry_size == 0) {
        return 0;
    }

    def header: k_fs_entry_header_t;
    if (k_fs_read_entry_header(dev, entry, &header) != 0) {
        return -1;
    } else if (header.entry_type != K_FS_ENTRY_TYPE_DIR) {
        return -1;
    }

    def total_size: u32 = header.payload_size / sizeof(k_fs_directory_entry_t);
    if (entry_offset >= total_size) {
        *entry_size = 0;
        return 0;
    }
    total_size = total_size - entry_offset;


    def byte_offset: u32 = entry_offset * sizeof(k_fs_directory_entry_t);
    def allowed_size: u32 = *entry_size;
    if (total_size < allowed_size) {
        *entry_size = total_size;
        allowed_size = total_size;
    }

    def read_size: u32 = allowed_size * sizeof(k_fs_directory_entry_t);
    return k_fs_read_entry_data(dev, entry, entries, &read_size, byte_offset);
}

fn k_fs_get_dir_entry_by_name(dev: *k_fs_disk_t, parent: u16, name: *u8, entry: *k_fs_directory_entry_t) i32 {
    def offset: u32 = 0;
    def entry_size: u32 = 1;
    def tmp: k_fs_directory_entry_t;
    def tmp_name: [K_FS_ENTRY_NAME_LEN + 1]u8;
    k_memset(&tmp_name, 0, K_FS_ENTRY_NAME_LEN + 1);

    while ((k_fs_read_directory_entries(dev, parent, &tmp, &entry_size, offset) == 0) && (entry_size > 0)) {
        k_memcpy(&tmp_name, &tmp.name, K_FS_ENTRY_NAME_LEN);
        if (strcmp(name, &tmp_name) == 0) {
            *entry = tmp;
            return 0;
        }

        offset = offset + 1;
    }

    return -1;
}

fn k_fs_get_dir_entry_by_id(dev: *k_fs_disk_t, parent: u16, base_block: u16, entry: *k_fs_directory_entry_t) i32 {
    def offset: u32 = 0;
    def entry_size: u32 = 1;
    def tmp: k_fs_directory_entry_t;

    while ((k_fs_read_directory_entries(dev, parent, &tmp, &entry_size, offset) == 0) && (entry_size > 0)) {
        if (tmp.base_block == base_block) {
            *entry = tmp;
            return 0;
        }

        offset = offset + 1;
    }

    return -1;
}

fn k_fs_disk_close(dev: *k_fs_disk_t) void {
    if (dev->entry_table_dirty) {
        k_fs_write_disk_table(dev);
    }
    k_free(dev->entry_table);
    k_free(dev);
}

#endif // KFS
