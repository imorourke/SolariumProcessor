#ifndef K_MALLOC
#define K_MALLOC

#include kserialio.cb

struct mem_val_t {
    size: u32;
    next: *mem_val_t;
    prev: *mem_val_t;
}

const K_MEM_SIZE: u32 = 0x10000u32;
const K_MEM_START: *u8 = 0x10000u32;
const K_MEM_TOP: *u8 = K_MEM_START + K_MEM_SIZE;
global K_MEM_ROOT: *mem_val_t = 0;

fn k_memset(dst: *u8, val: u8, size: u32) void {
    def i: u32 = 0;
    while (i < size) {
        *dst = val;
        dst = dst + 1;
        i = i + 1;
    }
}

asmfn k_memset_asm(dst: *u8, val: u8, size: u32) void {
    // Load Arguments
    "copy 8 $arg";
    "ldi 9:u16 #{val}#";
    "add 9:u32 9 8";
    "ld 9:u8 9"; // [9] = val
    "ldi 10:u16 #{size}#";
    "add 10:u32 10 8";
    "ld 10:u32 10"; // [10] = size
    "ldi 11:u16 1"; // [11] = 1
    "ld 8:u32 8"; // [8] = dst

    // Loop through to set each value
    "tl 12:u32 8 10";
    "tz 12";
    "jmpri 8";
    "jmpri 16";
    "sav 8:u8 9";
    "add 8:u32 8 1";
    "jmpri -24";

    // Return the result
    "ret";
}

fn k_memcpy(dst: *u8, src: *u8, size: u32) void {
    if ((dst == 0) || (src == 0)) return;
    def i: u32 = 0;
    while (i < size) {
        *dst = *src;
        dst = dst + 1;
        src = src + 1;
        i = i + 1;
    }
}

fn k_malloc(size: u32) *u8 {
    def val: *mem_val_t = K_MEM_ROOT;
    if (val == 0) {
        val = K_MEM_START;
        val->size = size;
        val->next = 0;
        val->prev = 0;
        K_MEM_ROOT = val;
    } else if ((K_MEM_START : u32) + size + sizeof(mem_val_t) < (K_MEM_ROOT : u32)) {
        val = K_MEM_START;
        val->prev = 0;
        val->next = K_MEM_ROOT;
        K_MEM_ROOT->prev = val;
        K_MEM_ROOT = val;
        val->size = size;
    } else {
        def found: u8 = 0;

        while (val->next != 0) {
            if (((val : u32) + val->size + sizeof(mem_val_t) * 2 + size) < (val->next : u32)) {
                def new_val: *mem_val_t = (val: u32) + val->size + sizeof(mem_val_t);
                new_val->size = size;
                new_val->next = val->next;
                val->next = new_val;
                new_val->prev = val;
                if (new_val->next != 0) {
                    new_val->next->prev = new_val;
                }
                val = new_val;
                found = 1;
                break;
            }
            val = val->next;
        }

        if (!found) {
            def new_val: *mem_val_t = (val : u32) + val->size + sizeof(mem_val_t);
            new_val->next = 0;
            new_val->prev = val;
            new_val->size = size;
            val->next = new_val;
            val = new_val;
        }
    }

    return (val : *u8) + sizeof(mem_val_t);
}

fn k_free(ptr: *u8) void {
    def block: *mem_val_t = (ptr - sizeof(mem_val_t)) : *mem_val_t;
    if (block->prev != 0) {
      if (block == K_MEM_ROOT) {
          K_MEM_ROOT = block->prev;
      }
      block->prev->next = block->next;
    }
    if (block->next != 0) {
        if (block == K_MEM_ROOT) {
            K_MEM_ROOT = block->next;
        }
        block->next->prev = block->prev;
    }
    if (block == K_MEM_ROOT) {
        K_MEM_ROOT = 0;
    }
}

fn k_heap_print() void {
    if (K_MEM_ROOT == 0) {
        k_io_print("No Heap Allocations\n");
    } else {
        def current: *mem_val_t = K_MEM_ROOT;
        while (current != 0) {
            k_io_print("@");
            k_io_print_uint(current : u32);
            k_io_print(", ");
            k_io_print_uint(current->size);
            k_io_print("\n");
            current = current->next;
        }
    }
}

#endif // K_MALLOC
