#ifndef K_SERIAL_IO
#define K_SERIAL_IO

#include kconfig.cb
#include kdevice.cb

struct k_serial_control_t {
    device_id: u16;
    input_size: u8;
    input_data: u8;
    output_size: u8;
    output_data: u8;
    reset_input: u8;
    reset_output: u8;
    interrupt_num: u8;
    interrupt_char: u8;
}

global SERIAL_DEV: *k_serial_control_t = 0;

fn k_io_init() void {
    def dev: *k_device_t = k_device_first_of_type(K_DEVICE_ID_SERIALIO);
    if (dev == 0) {
        SERIAL_DEV = 0;
        asm { "halt"; "reset"; }
    } else {
        SERIAL_DEV = dev->data;
        SERIAL_DEV->interrupt_num = 0;
        SERIAL_DEV->interrupt_char = 0;
    }
}

#ifdef K_SERIAL_IO_CBUOY_PRINT
fn k_io_print_intf(out_dev: *u8, c: *u8) void {
    while (*c != 0) {
        *out_dev = *c;
        c = c + 1;
    }
}

fn k_io_print_digit_intf(out_dev: *u8, v: u8) void {
    if (v < 10) {
        *out_dev = '0' + v;
    } else {
        *out_dev = '?';
    }
}
#else
asmfn k_io_print_intf(out_dev: *u8, c: *u8) void {
    "push $stat";
    "intoff";
    "ldi 8:u16 @{out_dev}@";
    "add 8:u32 $arg 8";
    "ld 8:u32 8";
    "ldi 9:u16 1";
    "ldi 10:u16 @{c}@";
    "add 10:u32 $arg 10";
    "ld 10:u32 10";
    "ld 11:u8 10";
    "tz 11";
    "jmpri 16";
    "sav 8:u8 11";
    "add 10:u32 10 9";
    "jmpri -20";
    "popr $stat";
    "ret";
}

asmfn k_io_print_digit_intf(out_dev: *u8, v: u8) void {
    "ldi 9:u16 @{v}@";
    "add 9:u32 $arg 9";
    "ld 9:u8 9";
    "ldi 10:u16 10";
    "ldi 11:u16 @{out_dev}@";
    "add 11:u32 11 $arg";
    "ld 11:u32 11";
    "tl 12:u8 9 10";
    "tz 12";
    "jmpri 16";
    "ldi 10:u16 '0'";
    "add 10:u8 9 10";
    "jmpri 8";
    "ldi 10:u16 0x3F";
    "sav 11:u8 10";
    "ret";
}
#endif

fn k_io_print(c: *u8) void {
    k_io_print_intf(&(SERIAL_DEV->output_data), c);
}

fn k_io_print_digit(v: u8) void {
    k_io_print_digit_intf((&SERIAL_DEV->output_data), v);
}

fn k_io_print_uint(v: u32) void {
    def chars: [12]u8;
    def cp: *u8 = chars;
    if (v == 0) {
        k_io_print_digit(0);
    } else {
        while (v != 0) {
            *cp = v % 10;
            v = v / 10;
            cp = cp + 1;
        }
        while (cp != chars) {
            cp = cp - 1;
            k_io_print_digit(*cp);
        }
    }
}

fn k_io_print_int(v: i32) void {
    if (v < 0) {
        v = -v;
        k_io_print("-");
    }
    k_io_print_uint(v : u32);
}

fn k_io_print_hex(v: u32) void {
    def chars: [12]u8;
    def cp: *u8 = chars;
    if (v == 0) {
        k_io_print_digit(0);
    } else {
        while (v != 0) {
            *cp = v % 16;
            v = v / 16;
            cp = cp + 1;
        }
        while (cp != chars) {
            cp = cp - 1;
            if (*cp < 10) {
                (SERIAL_DEV->output_data) = '0' + *cp;
            } else {
                (SERIAL_DEV->output_data) = 'A' + (*cp - 10);
            }
        }
    }
}

fn k_io_print_stat(name: *u8, v: u32) void {
    k_io_print(name);
    k_io_print(": ");
    k_io_print_uint(v);
    k_io_print("\n");
}

fn k_io_read_char() u8 {
    return (SERIAL_DEV->input_data);
}

fn k_io_read_char_immediate() u8 {
    if (SERIAL_DEV->input_size > 0) {
        return (SERIAL_DEV->input_data);
    } else {
        return 0u8;
    }
}

// NOTE - WILL NULL TERMINATE!
fn k_io_read_str_until(buffer: *u8, len: u32, target: u8) u32 {
    if (len == 0) {
        return 0;
    } else {
        def i: *u8 = buffer;
        def end: *u8 = (buffer + len - 1);

        def num_read: u32 = 0;

        while (i != end) {
            if (SERIAL_DEV->input_size > 0) {
                *i = (SERIAL_DEV->input_data);
                num_read = num_read + 1;
                if (*i == target) {
                    *(i + 1) = 0;
                    break;
                }
                i = i + 1;
            }
        }

        return num_read;
    }
}

#endif // K_SERIAL_IO
